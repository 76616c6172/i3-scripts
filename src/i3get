#!/usr/bin/env bash

___printversion(){
  
cat << 'EOB' >&2
i3get - version: 0.72
updated: 2021-06-07 by budRich
EOB
}



main(){

  result=$(get_window)
  timeout=$SECONDS

  ((__o[synk])) && [[ ! $result ]] && sleep .1 && while :; do
    result=$(get_window)
    [[ $((SECONDS-timeout)) -gt 60 || $result ]] && break
    i3-msg -qt subscribe '["window"]'
  done

  [[ $result ]] || ERX "i3get: no matching window"
  echo "$result"
}

___printhelp(){
  
cat << 'EOB' >&2
i3get - prints info about a specific window to stdout


SYNOPSIS
--------
i3get [--class|-c CLASS] [--instance|-i INSTANCE] [--title|-t TITLE] [--conid|-n CON_ID] [--id|-d WIN_ID] [--mark|-m MARK] [--titleformat|-o TITLE_FORMAT] [--active|-a] [--synk|-y] [--print|-r OUTPUT] [--json TREE]
i3get --help|-h
i3get --version|-v

OPTIONS
-------

--class|-c CLASS  
Search for windows with the given class


--instance|-i INSTANCE  
Search for windows with the given instance


--title|-t TITLE  
Search for windows with title.


--conid|-n CON_ID  
Search for windows with the given con_id


--id|-d WIN_ID  
Search for windows with the given window id


--mark|-m MARK  
Search for windows with the given mark


--titleformat|-o TITLE_FORMAT  
Search for windows with the given titleformat


--active|-a  
Currently active window (default)


--synk|-y  
Synch on. If this option is included,  script
will wait till target window exist. (or timeout
after 60 seconds).


--print|-r OUTPUT  
OUTPUT can be one or more of the following 
characters:  


|character | print            | return
|:---------|:-----------------|:------
|t         | title            | string
|c         | class            | string
|i         | instance         | string
|d         | Window ID        | INT
|n         | Con_Id (default) | INT
|m         | mark             | JSON list
|w         | workspace        | INT
|a         | is active        | true or false
|f         | floating state   | string
|o         | title format     | string
|e         | fullscreen       | 1 or 0
|s         | sticky           | true or false
|u         | urgent           | true or false
|y         | window_type      | string

Each character in OUTPUT will be tested and the
return value will be printed on a new line. If no
value is found, --i3get could not find: CHARACTER
will get printed.

In the example below, the target window did not
have a mark:  


   $ i3get -r tfcmw
   /dev/pts/9
   user_off
   URxvt
   --i3get could not find: m
   1




--json TREE  
Use TREE instead of the output of  
i3-msg -t get_tree


--help|-h  
Show help and exit.


--version|-v  
Show version and exit

EOB
}


awklib() {
cat << 'EOB'
END {

  if ( !arg_target ) {
    target_container_id=active_container_id
  } else {

    for (suspect_id in suspect_targets) {

      search_match=0

      for (search in arg_search) { 
        if (match(ac[suspect_id][search],arg_search[search]))
          search_match+=1
      }

      if (search_match == length(arg_search)) {
        target_container_id=suspect_id
        break
      }
    }
  }

  if (! target_container_id)
    exit

  split(arg_print,toprint,"")

  for (k in toprint) {
    switch(toprint[k]) {

      case "t":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["name"])
      break

      case "c":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["class"])
      break

      case "i":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["instance"])
      break

      case "d":
        print ac[target_container_id]["window"]
      break

      case "n":
        print target_container_id
      break

      case "m":
        print ac[target_container_id]["marks"]
      break

      case "w":
        print ac[target_container_id]["workspace"]
      break

      case "a":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["focused"])
      break

      case "f":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["floating"])
      break

      case "o":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["title_format"])
      break

      case "e":
        print ac[target_container_id]["fullscreen_mode"]
      break

      case "s":
        print ac[target_container_id]["sticky"]
      break

      case "u":
        print ac[target_container_id]["urgent"]
      break

      case "y":
        print gensub(/^"|"$/,"","g",ac[target_container_id]["window_type"])
      break
    }
  }
}
# add x to list to grab geometry
$(NF-1) ~ /"(id|window|name|urgent|num|floating|sticky|title_format|fullscreen_mode|marks|focused|instance|class|focus|window_type)"$/ {
  
  key=gensub(/.*"([^"]+)"$/,"\\1","g",$(NF-1))
    
  switch (key) {

    
    case "fullscreen_mode":
    case "sticky":
    case "urgent":
    case "window_type":
      ac[cid][key]=$NF
    break

    case "class":
    case "instance":
    case "title_format":
      ac[cid][key]=$NF
      if ( key == arg_target && $NF == "\"" arg_search[key] "\"" )
        suspect_targets[cid]=1
    break

    # if $NF doesnt end with ", 
    # its a comma in the name
    # use getline in that case
    case "name":
      title=gensub(/\\"/,"@@_DQ_@@","g",$NF)
      while (title ~ /[^"]$/ && title != "null") {
        getline
        title = title "," gensub(/\\"/,"@@_DQ_@@","g",$0)
      }
      title=gensub("@@_DQ_@@","\"","g",title)
      ac[cid][key]=title
      if ( key == arg_target && match(title, arg_search[key]) )
        suspect_targets[cid]=1
    break

    case "id":
      # when "nodes": (or "floating_nodes":) and "id":
      # is on the same record.
      #   example -> "nodes":[{"id":94446734049888 
      # it is the start of a branch in the tree.
      # save the last container_id as current_parent_id
      if ($1 ~ /nodes"$/) {
        current_parent_id=cid
      } else if (NR == 1) {
        root_id=$NF
      }


      # cid, "current id" is the last seen container_id
      cid=$NF
      ac[cid][key]=$NF

      if ( key == arg_target && match($NF, arg_search[key]) )
        suspect_targets[cid]=1
    break

    case "x":

      if ($1 ~ /"(deco_)?rect"/) {
        # this will add values to:
        #   ac[cid]["x"] , ["y"] , ["w"] , ["h"]
        #   ac[cid]["deco_x"] , ["deco_y"] , ["deco_w"] , ["deco_h"]
        keyprefix=($1 ~ /"deco_rect"/ ? "deco_" : "")
        while (1) {

          match($0,/"([^"])[^"]*":([0-9]+)([}])?$/,ma)
          ac[cid][keyprefix ma[1]]=ma[2]
          if (ma[3] ~ "}")
            break
          # break before getline, otherwise we will
          # miss the "deco_rect" line..
          getline
        }
      }

    break

    case "num":
      ac[cid][key]=$NF
      cwsid=cid # current workspace id
    break

    case "focused":
      ac[cid][key]=$NF
      if ($NF == "true") {
        active_container_id=cid
        active_workspace_id=cwsid
      }
      ac[cid]["workspace"]=ac[cwsid]["num"]
      ac[cid]["parent"]=current_parent_id
    break

    case "window":
      if ($NF != "null") {
        ac[cid]["window"]=$NF
        if ( key == arg_target && $NF == arg_search[key] )
          suspect_targets[cid]=1
      }
    break

    case "floating":
      ac[cid]["floating"]=$NF
    break

    case "focus":
      if ($2 != "[]") {
        # a not empty focus list is the first thing
        # we encounter after a branch. The first
        # item of the list is the focused container
        # which is of interest if the container is
        # tabbed or stacked, where only the focused container
        # is visible.
        first_id=gensub(/[^0-9]/,"","g",$2)
        parent_id=ac[first_id]["parent"]
        ac[parent_id]["focused"]=first_id

        # this restores current_parent_id  and cid 
        # to what it was before this branch.
        cid=parent_id
        current_parent_id=ac[parent_id]["parent"]
      }
    break

    case "marks":

      if ($NF == "[]") {
        ac[cid][key] = $NF
        break
      }

      if ( key == arg_target && match($NF, "\"" arg_search[key] "\"") )
        suspect_targets[cid]=1

      # ac[cid][key]="["
      while (1) {
        match($0,/"([^"]+)"([]])?$/,ma)
        ac[cid][key] = ( ac[cid][key] ? ac[cid][key] "," : "[" ) "\"" ma[1] "\""
        if (ma[2] ~ "]")
          break

        getline
      }

      ac[cid][key] = ac[cid][key] "]"

    break
  }
}
EOB
}

set -E
trap '[ "$?" -ne 77 ] || exit 77' ERR

ERX() { echo  "[ERROR] $*" >&2 ; exit 77 ;}
ERR() { echo  "[WARNING] $*" >&2 ;}
ERM() { echo  "$*" >&2 ;}

get_window() {

  local json
  json=${__o[json]:-$(i3-msg -t get_tree)}

  awk -f <(
    echo "
    BEGIN {
      ${__o[instance]:+
        arg_target=\"instance\"
        arg_search[arg_target]=\"${__o[instance]}\"
      }
      ${__o[class]:+
        arg_target=\"class\"
        arg_search[arg_target]=\"${__o[class]}\"
      }
      ${__o[conid]:+
        arg_target=\"id\"
        arg_search[arg_target]=\"${__o[conid]}\"
      }
      ${__o[id]:+
        arg_target=\"window\"
        arg_search[arg_target]=\"${__o[id]}\"
      }
      ${__o[mark]:+
        arg_target=\"marks\"
        arg_search[arg_target]=\"${__o[mark]}\"
      }
      ${__o[title]:+
        arg_target=\"name\"
        arg_search[arg_target]=\"${__o[title]}\"
      }
      ${__o[titleformat]:+
        arg_target=\"title_format\"
        arg_search[arg_target]=\"${__o[titleformat]}\"
      }
      arg_print=\"${__o[print]:-n}\"
    }"
    awklib
  ) FS=: RS=, <<< "$json"
}


declare -A __o
options="$(
  getopt --name "[ERROR]:i3get" \
    --options "c:i:t:n:d:m:o:ayr:hv" \
    --longoptions "class:,instance:,title:,conid:,id:,mark:,titleformat:,active,synk,print:,json:,help,version," \
    -- "$@" || exit 77
)"

eval set -- "$options"
unset options

while true; do
  case "$1" in
    --class      | -c ) __o[class]="${2:-}" ; shift ;;
    --instance   | -i ) __o[instance]="${2:-}" ; shift ;;
    --title      | -t ) __o[title]="${2:-}" ; shift ;;
    --conid      | -n ) __o[conid]="${2:-}" ; shift ;;
    --id         | -d ) __o[id]="${2:-}" ; shift ;;
    --mark       | -m ) __o[mark]="${2:-}" ; shift ;;
    --titleformat | -o ) __o[titleformat]="${2:-}" ; shift ;;
    --active     | -a ) __o[active]=1 ;; 
    --synk       | -y ) __o[synk]=1 ;; 
    --print      | -r ) __o[print]="${2:-}" ; shift ;;
    --json       ) __o[json]="${2:-}" ; shift ;;
    --help       | -h ) ___printhelp && exit ;;
    --version    | -v ) ___printversion && exit ;;
    -- ) shift ; break ;;
    *  ) break ;;
  esac
  shift
done

[[ ${__lastarg:="${!#:-}"} =~ ^--$|${0}$ ]] \
  && __lastarg="" 


main "${@}"


