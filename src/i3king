#!/bin/bash

___printversion(){
  
cat << 'EOB' >&2
i3king - version: 0.27
updated: 2021-09-11 by budRich
EOB
}


# environment variables
: "${XDG_CONFIG_HOME:=$HOME/.config}"
: "${XDG_RUNTIME_DIR:=/tmp}"
: "${I3_KING_RULE_FILE:=$XDG_CONFIG_HOME/i3king/rules}"
: "${I3_KING_PID_FILE:=$XDG_RUNTIME_DIR/i3ass/i3king.pid}"


main(){

  declare -Ag ma

  declare -ag global_rules
  declare -ag default_rules
  declare -ag close_rules
  declare -ag rules
  declare -ag commands
  declare -g  _fs=$'\x1f' # field separator, US

  ((__o[verbose])) && {
    ERM "i3king start"
    _file_log=/dev/stderr
  }

  [[ ${__o[log]} ]] && {
    _file_log=${__o[log]}
    mkdir -p "${_file_log%/*}"
    {
      date
      echo ---------------------------------
    } >> "$_file_log"
  }

  _file_rules=${__o[config]:-$I3_KING_RULE_FILE}

  # create default config file if it doesn't exist
  [[ -f $_file_rules ]] || {
    [[ -f $I3_KING_RULE_FILE ]] \
      || createconf "${I3_KING_RULE_FILE%/*}"
    _file_rules=$I3_KING_RULE_FILE
  }

  parse_rules "$_file_rules"

  if [[ ${__o[apply]} ]]; then
    apply_rules
    exit
  elif [[ ${__o[conid]} ]]; then
    mapfile -t wininfo <<< "$(i3get -n "${__o[conid]}" -r ncityd)"
    match_window "${wininfo[@]}"
    exit
  fi

  trap 'rm -rf "$I3_KING_PID_FILE"' HUP INT EXIT
  trap 'exec $0 "${BASH_ARGV[@]}"' USR1

  mkdir -p "${I3_KING_PID_FILE%/*}"
  echo "$$" > "$I3_KING_PID_FILE"

  re=$(make_regex)
  
  while :; do
    while read -r json ; do

      if [[ ${json//\\\"/%DQ%} =~ $re ]]; then

        i=1
        ma=(
          [change]="${BASH_REMATCH[++i]}"          # "change:"          - STRING
          [cid]="${BASH_REMATCH[++i]}"             # "id:"              - INT
          [urgent]="${BASH_REMATCH[++i]}"          # "urgent:"          - false|true
          [O]="${BASH_REMATCH[++i]}"               # ! optional group
          [mrk]="${BASH_REMATCH[++i]}"             # "marks:"           - ["mark1","mark2"...]
          [focused]="${BASH_REMATCH[++i]}"         # "focused:"         - false|true
          [x]="${BASH_REMATCH[++i]}"               # rect
          [y]="${BASH_REMATCH[++i]}"               # rect
          [w]="${BASH_REMATCH[++i]}"               # rect
          [h]="${BASH_REMATCH[++i]}"               # rect
          [b]="${BASH_REMATCH[++i]}"               # deco_rect, height. i.e. titlebar height
          [title]="${BASH_REMATCH[++i]//%DQ%/\"}"  # "name:"            - STRING
          [O]="${BASH_REMATCH[++i]}"               # ! optional group
          [frm]="${BASH_REMATCH[++i]//%DQ%/\"}"    # "title_format:"    - string
          [wid]="${BASH_REMATCH[++i]}"             # "window:"          - INT
          [typ]="${BASH_REMATCH[++i]}"             # "window_type:"     - STRING
          [O]="${BASH_REMATCH[++i]}"               # ! optional group
          [cls]="${BASH_REMATCH[++i]}"             # "class:"           - STRING
          [O]="${BASH_REMATCH[++i]}"               # "instance:"        - STRING
          [ins]="${BASH_REMATCH[++i]}"             # "instance:"        - STRING
          [fullscreen]="${BASH_REMATCH[++i]}"      # "fullscreen_mode:" - 0|1
          [sticky]="${BASH_REMATCH[++i]}"          # "sticky:"          - true|false
          [floating]="${BASH_REMATCH[++i]}"        # "floating:"        - auto_off|auto_on|user_off|user_on
          [O]="${BASH_REMATCH[++i]}"               # "swallows:"        - auto_off|auto_on|user_off|user_on
        )

        match_window "${ma[cid]}"       \
                     "${ma[cls]:-.*}"   \
                     "${ma[ins]:-.*}"   \
                     "${ma[title]:-.*}" \
                     "${ma[typ]:-.*}"   \
                     "${ma[wid]}"       \
                     "${ma[change]}"
      fi

    done < <(
              if [[ ${__o[json]} ]]; then
                echo "${__o[json]}"
              else
                i3-msg -mt subscribe '["window"]'
              fi
            )

    [[ ${__o[no-restart]} || ! -f "$I3_KING_PID_FILE" || ${__o[json]} ]] \
      && break

    while :; do
      sleep .1
      [[ -S $(i3 --get-socketpath) ]] && break
    done

    [[ ${__o[no-apply]} ]] || apply_rules
  done
}

___printhelp(){
  
cat << 'EOB' >&2
i3king - window ruler


SYNOPSIS
--------
i3king [--config|-c FILE] [--no-apply] [--no-restart]
i3king --apply|-a [--config|-c FILE]
i3king --conid|-n CONID [--print-commands] [--config|-c FILE]
i3king --json JSON [--verbose] [--dryrun] [--log FILE]
i3king --help|-h
i3king --version|-v

OPTIONS
-------

--config|-c FILE  
Override the value of the Environment variable
I3_KING_RULE_FILE . Or the default value:  
~/.config/i3king/rules


--no-apply  
If this option is set it will not automatically
apply rules to all windows when the IPC socket is
broken (happens on a crash or on restart). This
option has no effect if --no-restart is used.

--no-restart  
When the IPC socket is broken, i3king will
automatically restart if this option is not set.


--apply|-a  
Match all existing windows against the rules and
exit.


--conid|-n CONID  
will match window with CONID against the rules
and exit.


--print-commands  
Print commands to STDOUT instead of executing
them.


--json JSON  
Parse JSON instead of the output from: i3-msg -t
subscribe


--verbose  
More verbose output to STDERR.


--dryrun  
Parse rules but don't execute commands.


--log FILE  
Same as verbose but the output is printed to FILE
instead.


--help|-h  
Show help and exit.


--version|-v  
Show version and exit.

EOB
}


apply_rules() {
  declare -a ids
  declare -a wininfo
  mapfile -t ids <<< "$(all_window_ids)"

  # cid=$1 class=$2 instance=$3 title=$4 type=$5
  for id in "${ids[@]}"; do
    mapfile -t wininfo <<< "$(i3get -d "$id" -r ncityd)"
    sleep .1
    match_window "${wininfo[@]}" apply
  done
}

all_window_ids() {
  i3-msg -t get_tree \
    | awk '$1 == "\"window\"" && $2 != "null" {print $2}' RS=, FS=:
}

### createconf() function is automatically generated
### by bashbud based on the content of the conf/ directory

createconf() {
local trgdir="$1"
declare -a aconfdirs

aconfdirs=(
)

mkdir -p "$1" "${aconfdirs[@]}"

cat << 'EOCONF' > "$trgdir/rules"
# if the first nonblank character is "#", the line is ignored (comment)
# blank lines are also ignored.

# rules are always declared before the commands:
instance=firefox title="a window title|tab"
# the commands need to be on one line and indented with whitespace:
# the commands are sent to i3-msg, so to execute
# "other" commands you need to use 'exec' just as in 
# the i3 config.
  exec --no-startup-id notify-send "a firefox window was created"

# it is also possible to use 'set' like in the i3 config
# to make variables.
set $X   exec --no-startup-id
set $MSG exec --no-startup-id notify-send

# global rules will apply to all windows
GLOBAL
  $MSG "a new window was created"

# default rules applies to any window that does
# not match a "normal" rule
# in this file it will never get triggered, since
# the above GLOBAL rule is considered normal and
# will always trigger.
DEFAULT
  $MSG "no other rules matched"

# global rule declarations can be followed by a rule.
# windows matching such a rule will be ignored.
GLOBAL class=URxvt
  $MSG "this is NOT a URxvt window"

# use comma to group rules to the same command
class=URxvt , instance=firefox
  $MSG "this is a terminal or browser window"

# this also works for global rules
GLOBAL class=URxvt , instance=firefox
  $MSG "this is NOT a URxvt or firefox window"

# lines ending with backslash (\)
# will get added to the beginning of the next line
# the rule below is equivalent to the one above:
GLOBAL \
  class=URxvt ,\
  instance=firefox
    $MSG "this is NOT a URxvt or firefox window"

ON_CLOSE instance=firefox
  $MSG "the firefox window is now closed"

# use semicolon to execute more then one command,
# notice that we need exec after the semicolon ($X/$MSG)
class=URxvt
  $MSG "this is a terminal window" ;\
  $MSG "the instance name is $INSTANCE"
EOCONF

}

set -E
trap '[ "$?" -ne 98 ] || exit 98' ERR

ERX() { >&2 echo  "[ERROR] $*" ; exit 98 ;}
ERR() { >&2 echo  "[WARNING] $*"  ;}
ERM() { >&2 echo  "$*"  ;}
ERH(){
  ___printhelp >&2
  [[ -n "$*" ]] && printf '\n%s\n' "$*" >&2
  exit 98
}


make_regex() {

local re

re+=$(cat << EOB
(\{)
"change":"(new|close)",
"container":[{]
"id":([0-9]+),
"type":"[^"]+",
"orientation":"[^"]+",
"scratchpad_state":"[^"]+",
"percent":[0-9.]+,
"urgent":(false|true),
("marks":(\[[^]]*\]),)?
"focused":(true|false),
"output":"[^"]+",
"layout":"[^"]+",
"workspace_layout":"[^"]+",
"last_split_layout":"[^"]+",
"border":"[^"]+",
"current_border_width":[0-9-]+,
"rect":[{]"x":([0-9]+),"y":([0-9]+),"width":([0-9]+),"height":([0-9]+)},
"deco_rect":[^g]+ght":([0-9]+)},
"window_rect":[^}]+},
"geometry":[^}]+},
"name":"?([^\"]+)"?,
("title_format":"([^"]+)",)?
"window":(${_c[id]:-[0-9]+}),
"window_type":"([^"]+)",
"window_properties":\{
("class":"([^"]+)",)?
("instance":"([^"]+)",)?
[^}]+\},
"nodes":[^,]+,
"floating_nodes":[^,]+,
"focus":[^,]+,
"fullscreen_mode":([0-9]),
"sticky":(false|true),
"floating":"([^"]+)",
("swallows":.+)?
EOB
)

# remove all newline characters
echo "${re//$'\n'/}"
}

match_window() {

  local cid=$1 class=$2 instance=$3 title=$4 wid=$6 change=$7
  # local type=$5 # unused
  local last_cmd cmd rule

  local identifier=""

  identifier+="class$_fs$2$_fs"
  identifier+="instance$_fs$3$_fs"
  identifier+="title$_fs$4$_fs"
  identifier+="window_type$_fs$5$_fs"

  declare -a matches default_execute execute

  [[ $cid =~ ^[0-9]{5,}$ ]] \
    || ERX "match_window(): $cid is not a valid containerID"

  if [[ $change = close ]]; then
    for rule in "${!close_rules[@]}"; do
      [[ $identifier =~ ${close_rules[$rule]} ]] || continue
      cmd=${commands[$rule]}
      [[ $cmd = "$last_cmd" ]] && continue
      last_cmd=$cmd

      execute+=("$cmd")
      matches+=("ON_CLOSE: ${close_rules[$rule]}"$'\n'$'\t'"$cmd")
    done
  else
    # test default rules first
    for rule in "${!default_rules[@]}"; do

      cmd=${commands[$rule]}

      [[ $identifier =~ ${default_rules[$rule]} ]] && {

        [[ $cmd = "$last_cmd" ]] && {
          unset 'default_execute[-1]'
          unset 'matches[-1]'
        }
        last_cmd=$cmd
        continue
      }

      [[ $cmd = "$last_cmd" ]] && continue
      last_cmd=$cmd

      default_execute+=("$cmd")
      matches+=("DEFAULT: -"$'\n'$'\t'"$cmd")

    done

    unset last_cmd

    # then global rules
    for rule in "${!global_rules[@]}"; do

      cmd=${commands[$rule]}

      [[ $identifier =~ ${global_rules[$rule]} ]] && {

        [[ $cmd = "${execute[-1]}" ]] && {
          unset 'execute[-1]'
          unset 'matches[-1]'
        }
        last_cmd=$cmd
        continue
      }

      [[ $cmd = "$last_cmd" ]] && continue
      last_cmd=$cmd

      execute+=("$cmd")
      matches+=("GLOBAL: -"$'\n'$'\t'"$cmd")
    done

    unset last_cmd

    for rule in "${!rules[@]}"; do
      [[ $identifier =~ ${rules[$rule]} ]] || continue
      cmd=${commands[$rule]}
      [[ $cmd = "$last_cmd" ]] && continue
      last_cmd=$cmd

      execute+=("$cmd")
      matches+=("NORMAL: ${rules[$rule]}"$'\n'$'\t'"$cmd")
    done
  fi

  [[ -a $_file_log && ${#matches[@]} -gt 0 ]] && {
    echo $'\n'"WINDOW: "\
     "${identifier//$_fs/:}"$'\n'
    for k in "${matches[@]}"; do
      echo "$k"
    done
    echo
    echo EXECUTE:
  } >> "$_file_log"

  ((${#execute[@]})) && unset 'default_execute[@]'
  ((${#default_execute[@]})) && execute=("${default_execute[@]}")

  ((${#execute[@]})) && {
    
    for k in "${execute[@]}"; do

      cmd=$k
      cmd=${cmd//\$INSTANCE/$instance}
      cmd=${cmd//\$CLASS/$class}
      cmd=${cmd//\$CONID/$cid}
      cmd=${cmd//\$WINID/$wid}
      cmd=${cmd//\$TITLE/$title}

      [[ -a $_file_log ]] && echo $'\t'"$cmd" >> "$_file_log"

      if [[ $change = close ]]; then
        # without prefixing command with ; 
        # the command is not executed everytime.
        # not sure why, but it works like this
        prefix=";"
      else
        # cant prefix with conid when we close
        # since the window doesn't exist
        prefix="[con_id=$cid]"
      fi

      ((__o[print-commands] || __o[dryrun])) || i3-msg "${prefix:-} $cmd"
      ((__o[print-commands])) && echo "${prefix:-} $cmd"
      
    done
  }
}

parse_rules() {

  declare -A vars
  local re_set re_group re_rule rule_type

  re_set='^\s*set\s+[$](\S+)\s+(.+)$'
  re_group='(\s*([^=[:space:]]+)=([^=]+\S)\s*)$'
  re_rule='^(GLOBAL|DEFAULT|ON_CLOSE)?((\s+)?(.+)\s*)?$'

  declare -i counter_criteria counter_commands
  
  while read -r  ; do

    line="${prevline:+$prevline }$REPLY"

    if [[ $line =~ \\$ ]]; then
      prevline=${line%\\}
      continue
    else
      unset prevline
    fi

    if [[ $line =~ ^[[:space:]]*$ ]]; then
      continue
    elif [[ $line =~ ^[[:space:]]*# ]]; then
      continue
    elif [[ $line =~ $re_set ]]; then
      vars["${BASH_REMATCH[1]}"]=${BASH_REMATCH[2]}
    elif [[ $line =~ ^[[:space:]]+(.+)[[:space:]]*$ ]]; then

      cmd=${BASH_REMATCH[1]}
      for k in "${!vars[@]}"; do
        cmd=${cmd//\$$k/${vars[$k]}}
      done

      # use command id instead of storing cmd string

      while ((counter_commands < counter_criteria)); do
        commands[counter_commands++]=$cmd
      done

    elif [[ $line =~ $re_rule ]]; then
      # re_rules=^(GLOBAL|DEFAULT|ON_CLOSE)?((\s+)?(.+)\s*)?$
      rule_type=${BASH_REMATCH[1]:-NORMAL}

      [[ $rule_type = ON_CLOSE && ! ${BASH_REMATCH[4]} ]] \
        && continue # criteria mandatory

      # group by comma
      mapfile -t ignore_combined <<< "${BASH_REMATCH[4]//,/$'\n'}"

      for crit in "${ignore_combined[@]}"; do

        # if we don't have  a criteria it is
        # a line with a single GLOBAL/NORMAL
        # we set the rule to nonsense (-)
        # to make sure it never matches
        if [[ $crit ]]; then
          wc="$_fs[^${_fs}]*$_fs" # wildcard :.*:
          rule="class${wc}instance${wc}title${wc}window_type${wc}"
        else
          rule=^-$
        fi

        while [[ $crit =~ $re_group ]]; do

          # re_group='(\s*([^=[:space:]]+)=([^=]+\S)\s*)$'

          crit=${crit:0:$((${#BASH_REMATCH[1]}*-1))}
          key=${BASH_REMATCH[2]} 
          val=${BASH_REMATCH[3]//\\s/[[:space:]]}
          val=${val// /[[:space:]]}

          # remove double quotes
          val=${val#\"} val=${val%\"}

          # ^ and $
          if [[ $val =~ ^\^(.+)\$$ ]]; then
            val="(${BASH_REMATCH[1]})"
          elif [[ $val =~ ^\^(.+) ]]; then
            val="(${BASH_REMATCH[1]})[^${_fs}]*"
          elif [[ $val =~ ^(.+)\$$ ]]; then
            val="[^${_fs}]*(${BASH_REMATCH[1]})"
          fi

          rule=${rule/$key${_fs}\[^${_fs}]\*${_fs}/$key${_fs}$val${_fs}}
        done

        [[ -a $_file_log ]] && {
          rule_out=${rule//$_fs/:}
          rule_out=${rule_out//\[^:]/.}
          echo "$rule_out" 
        } >> "$_file_log"

        case "$rule_type" in
          DEFAULT  ) default_rules[counter_criteria++]=$rule ;;
          GLOBAL   ) global_rules[counter_criteria++]=$rule  ;;
          ON_CLOSE ) close_rules[counter_criteria++]=$rule   ;;
          *        ) rules[counter_criteria++]=$rule         ;;
        esac

      done
    fi

  done < "$1"
}

# SC2034 __o appears unused.
# shellcheck disable=2034
declare -A __o
options="$(
  getopt --name "[ERROR]:i3king" \
    --options "c:an:hv" \
    --longoptions "config:,no-apply,no-restart,apply,conid:,print-commands,json:,verbose,dryrun,log:,help,version," \
    -- "$@" || exit 98
)"

eval set -- "$options"
unset options

while true; do
  case "$1" in
    --config     | -c ) __o[config]="${2:-}" ; shift ;;
    --no-apply   ) __o[no-apply]=1 ;; 
    --no-restart ) __o[no-restart]=1 ;; 
    --apply      | -a ) __o[apply]=1 ;; 
    --conid      | -n ) __o[conid]="${2:-}" ; shift ;;
    --print-commands ) __o[print-commands]=1 ;; 
    --json       ) __o[json]="${2:-}" ; shift ;;
    --verbose    ) __o[verbose]=1 ;; 
    --dryrun     ) __o[dryrun]=1 ;; 
    --log        ) __o[log]="${2:-}" ; shift ;;
    --help       | -h ) ___printhelp && exit ;;
    --version    | -v ) ___printversion && exit ;;
    -- ) shift ; break ;;
    *  ) break ;;
  esac
  shift
done

[[ ${__lastarg:="${!#:-}"} =~ ^--$|${0}$ ]] \
  && __lastarg="" 


main "${@:-}"


