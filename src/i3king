#!/bin/bash

___printversion(){
  
cat << 'EOB' >&2
i3king - version: 0.2
updated: 2021-08-06 by budRich
EOB
}


# environment variables
: "${XDG_CONFIG_HOME:=$HOME/.config}"
: "${I3_KING_RULE_FILE:=$XDG_CONFIG_HOME/i3king/rules}"


main(){

  declare -Ag ma

  declare -ag global_rules
  declare -ag default_rules
  declare -ag rules
  declare -ag commands

  ((__o[verbose])) && {
    ERM "i3king start"
    _file_log=/dev/stderr
  }

  [[ ${__o[log]} ]] && {
    _file_log=${__o[log]}
    mkdir -p "${_file_log%/*}"
    {
      date
      echo ---------------------------------
    } >> "$_file_log"
  }

  _file_rules=${__o[config]:-$I3_KING_RULE_FILE}

  # create default config file if it doesn't exist
  [[ -f $_file_rules ]] || {
    [[ -f $I3_KING_RULE_FILE ]] \
      || createconf "${I3_KING_RULE_FILE%/*}"
    _file_rules=$I3_KING_RULE_FILE
  }

  parse_rules "$_file_rules"

  [[ ${__o[apply]} ]] && {
    apply_rules
    exit
  }

  re=$(make_regex)
  
  while read -r json ; do

    [[ ${json//\\\"/%DQ%} =~ $re ]] && {

      i=1
      ma=(
        [change]="${BASH_REMATCH[++i]}"          # "num:"             - INT
        [cid]="${BASH_REMATCH[++i]}"             # "id:"              - INT
        [urgent]="${BASH_REMATCH[++i]}"          # "urgent:"          - false|true
        [O]="${BASH_REMATCH[++i]}"               # ! optional group
        [mrk]="${BASH_REMATCH[++i]}"             # "marks:"           - ["mark1","mark2"...]
        [focused]="${BASH_REMATCH[++i]}"         # "focused:"         - false|true
        [x]="${BASH_REMATCH[++i]}"               # rect
        [y]="${BASH_REMATCH[++i]}"               # rect
        [w]="${BASH_REMATCH[++i]}"               # rect
        [h]="${BASH_REMATCH[++i]}"               # rect
        [b]="${BASH_REMATCH[++i]}"               # deco_rect, height. i.e. titlebar height
        [title]="${BASH_REMATCH[++i]//%DQ%/\"}"  # "name:"            - STRING
        [O]="${BASH_REMATCH[++i]}"               # ! optional group
        [frm]="${BASH_REMATCH[++i]//%DQ%/\"}"    # "title_format:"    - string
        [wid]="${BASH_REMATCH[++i]}"             # "window:"          - INT
        [typ]="${BASH_REMATCH[++i]}"             # "window_type:"     - STRING
        [O]="${BASH_REMATCH[++i]}"               # ! optional group
        [cls]="${BASH_REMATCH[++i]}"             # "class:"           - STRING
        [O]="${BASH_REMATCH[++i]}"               # "instance:"        - STRING
        [ins]="${BASH_REMATCH[++i]}"             # "instance:"        - STRING
        [fullscreen]="${BASH_REMATCH[++i]}"      # "fullscreen_mode:" - 0|1
        [sticky]="${BASH_REMATCH[++i]}"          # "sticky:"          - true|false
        [floating]="${BASH_REMATCH[++i]}"        # "floating:"        - auto_off|auto_on|user_off|user_on
        [O]="${BASH_REMATCH[++i]}"               # "swallows:"        - auto_off|auto_on|user_off|user_on
      )

      match_window "${ma[cid]}"       \
                   "${ma[cls]:-.*}"   \
                   "${ma[ins]:-.*}"   \
                   "${ma[title]:-.*}" \
                   "${ma[typ]:-.*}"   \
                   "${ma[wid]}"
      
    }

    [[ $json = '{"change":"restart"}' ]] && restart=1

  done < <(
            if [[ ${__o[json]} ]]; then
              echo "${__o[json]}"
            else
              i3-msg -mt subscribe '["window","shutdown"]'
            fi
          )

  [[ $restart = 1 && ${__o[no-restart]} != 1 ]] && {

    echo "got restart event" >> "$_file_log"

    while :; do
      sleep .1
      [[ -S $(i3 --get-socketpath) ]] && break
    done

    apply_rules

    echo "restarting i3king" >> "$_file_log"
    exec "${BASH_SOURCE[0]}" "${BASH_ARGV[@]}"
  }
}

___printhelp(){
  
cat << 'EOB' >&2
i3king - window ruler


SYNOPSIS
--------
i3king [--config|-c FILE] [--no-restart]
i3king --apply|-a [--config|-c FILE]
i3king --json JSON [--verbose] [--dryrun] [--log FILE]
i3king --help|-h
i3king --version|-v

OPTIONS
-------

--config|-c FILE  
Override the value of the Environment variable
I3_KING_RULE_FILE . Or the default value:  
~/.config/i3king/rules


--no-restart  
When i3 emits the restart event all IPC
subscribers needs to be restarted. i3King does
this automatically but with this option set, it
will instead just die.

--apply|-a  
Match all existing windows against the rules and
exit.


--json JSON  
Parse JSON instead of the output from: i3-msg -t
subscribe


--verbose  
More verbose output to STDERR.


--dryrun  
Parse rules but don't execute commands.


--log FILE  
Same as verbose but the output is printed to FILE
instead.


--help|-h  
Show help and exit.


--version|-v  
Show version and exit.

EOB
}


apply_rules() {
	declare -a ids
	declare -a wininfo
	mapfile -t ids <<< "$(all_window_ids)"

	# cid=$1 class=$2 instance=$3 title=$4 type=$5
	for id in "${ids[@]}"; do
		mapfile -t wininfo <<< "$(i3get -d "$id" -r ncityd)"
		sleep .1
		match_window "${wininfo[@]}"
	done
}

all_window_ids() {
  i3-msg -t get_tree \
    | awk '$1 == "\"window\"" && $2 != "null" {print $2}' RS=, FS=:
}

### createconf() function is automatically generated
### by bashbud based on the content of the conf/ directory

createconf() {
local trgdir="$1"
declare -a aconfdirs

aconfdirs=(
)

mkdir -p "$1" "${aconfdirs[@]}"

cat << 'EOCONF' > "$trgdir/rules"
# if the first nonblank character is "#", the line is ignored (comment)
# blank lines are also ignored.

# rules are always declared before the commands:
instance=firefox title="a window title|tab"
# the commands need to be on one line and indented with whitespace:
# the commands are sent to i3-msg, so to execute
# "other" commands you need to use 'exec' just as in 
# the i3 config.
  exec --no-startup-id notify-send "a firefox window was created"

# it is also possible to use 'set' like in the i3 config
# to make variables.
set $X   exec --no-startup-id
set $MSG exec --no-startup-id notify-send

# global rules will apply to all windows
GLOBAL
  $MSG "a new window was created"

# default rules applies to any window that does
# not match a "normal" rule
# in this file it will never get triggered, since
# the above GLOBAL rule is considered normal and
# will always trigger.
DEFAULT
  $MSG "no other rules matched"

# global rule declarations can be followed by a rule.
# windows matching such a rule will be ignored.
GLOBAL class=URxvt
  $MSG "this is NOT a URxvt window"

# use comma to group rules to the same command
class=URxvt , instance=firefox
  $MSG "this is a terminal or browser window"

# this also works for global rules
GLOBAL class=URxvt , instance=firefox
  $MSG "this is NOT a URxvt or firefox window"

# lines ending with backslash (\)
# will get added to the beginning of the next line
# the rule below is equivalent to the one above:
GLOBAL \
  class=URxvt ,\
  instance=firefox
    $MSG "this is NOT a URxvt or firefox window"

# use semicolon to execute more then one command,
# notice that we need exec after the semicolon ($X/$MSG)
class=URxvt
  $MSG "this is a terminal window" ;\
  $MSG "the instance name is $INSTANCE"
EOCONF

}

set -E
trap '[ "$?" -ne 98 ] || exit 98' ERR

ERX() { >&2 echo  "[ERROR] $*" ; exit 98 ;}
ERR() { >&2 echo  "[WARNING] $*"  ;}
ERM() { >&2 echo  "$*"  ;}
ERH(){
  ___printhelp >&2
  [[ -n "$*" ]] && printf '\n%s\n' "$*" >&2
  exit 98
}


make_regex() {

local re

re+=$(cat << EOB
(\{)
"change":"(new)",
"container":[{]
"id":([0-9]+),
"type":"[^"]+",
"orientation":"[^"]+",
"scratchpad_state":"[^"]+",
"percent":[0-9.]+,
"urgent":(false|true),
("marks":(\[[^]]*\]),)?
"focused":(true|false),
"output":"[^"]+",
"layout":"[^"]+",
"workspace_layout":"[^"]+",
"last_split_layout":"[^"]+",
"border":"[^"]+",
"current_border_width":[0-9-]+,
"rect":[{]"x":([0-9]+),"y":([0-9]+),"width":([0-9]+),"height":([0-9]+)},
"deco_rect":[^g]+ght":([0-9]+)},
"window_rect":[^}]+},
"geometry":[^}]+},
"name":"?([^\"]+)"?,
("title_format":"([^"]+)",)?
"window":(${_c[id]:-[0-9]+}),
"window_type":"([^"]+)",
"window_properties":\{
("class":"([^"]+)",)?
("instance":"([^"]+)",)?
[^}]+\},
"nodes":[^,]+,
"floating_nodes":[^,]+,
"focus":[^,]+,
"fullscreen_mode":([0-9]),
"sticky":(false|true),
"floating":"([^"]+)",
("swallows":.+)?
EOB
)

# remove all newline characters
echo "${re//$'\n'/}"
}

match_window() {

  local cid=$1 class=$2 instance=$3 title=$4 wid=$6
  # local type=$5 # unused
  local last_cmd cmd rule
  local identifier="class:$2:instance:$3:title:$4:window_type:$5:"

  declare -a matches default_execute execute

  [[ $cid =~ ^[0-9]{5,}$ ]] \
    || ERX "match_window(): $cid is not a valid containerID"

  # test default rules first
  for rule in "${!default_rules[@]}"; do

    cmd=${commands[$rule]}

    [[ $identifier =~ ${default_rules[$rule]} ]] && {

      [[ $cmd = "$last_cmd" ]] && {
        unset 'default_execute[-1]'
        unset 'matches[-1]'
      }
      last_cmd=$cmd
      continue
    }

    [[ $cmd = "$last_cmd" ]] && continue
    last_cmd=$cmd

    default_execute+=("$cmd")
    matches+=("DEFAULT: -"$'\n'$'\t'"$cmd")

  done

  unset last_cmd

  # then global rules
  for rule in "${!global_rules[@]}"; do

    cmd=${commands[$rule]}

    [[ $identifier =~ ${global_rules[$rule]} ]] && {

      [[ $cmd = "${execute[-1]}" ]] && {
        unset 'execute[-1]'
        unset 'matches[-1]'
      }
      last_cmd=$cmd
      continue
    }

    [[ $cmd = "$last_cmd" ]] && continue
    last_cmd=$cmd

    execute+=("$cmd")
    matches+=("GLOBAL: -"$'\n'$'\t'"$cmd")
  done

  unset last_cmd

  for rule in "${!rules[@]}"; do
    [[ $identifier =~ ${rules[$rule]} ]] || continue
    cmd=${commands[$rule]}
    [[ $cmd = "$last_cmd" ]] && continue
    last_cmd=$cmd

    execute+=("$cmd")
    matches+=("NORMAL: ${rules[$rule]}"$'\n'$'\t'"$cmd")
  done

  [[ -a $_file_log && ${#matches[@]} -gt 0 ]] && {
    echo $'\n'"WINDOW: $identifier"$'\n'
    for k in "${matches[@]}"; do
      echo "$k"
    done
    echo
    echo EXECUTE:
  } >> "$_file_log"

  ((${#execute[@]})) && unset 'default_execute[@]'
  ((${#default_execute[@]})) && execute=("${default_execute[@]}")

  ((${#execute[@]})) && {
    
    for k in "${execute[@]}"; do

      cmd=$k
      cmd=${cmd//\$INSTANCE/$instance}
      cmd=${cmd//\$CLASS/$class}
      cmd=${cmd//\$CONID/$cid}
      cmd=${cmd//\$WINID/$wid}

      [[ -a $_file_log ]] && echo $'\t'"$cmd" >> "$_file_log"

      ((__o[dryrun])) || i3-msg "[con_id=$cid]" "$cmd"
      
    done
  }
}

parse_rules() {

  declare -A vars
  local re_set re_group re_rule

  re_set='^\s*set\s+[$](\S+)\s+(.+)$'
  re_group='(\s*([^=[:space:]]+)=([^=]+\S)\s*)$'
  re_rule='^(GLOBAL|DEFAULT)?((\s+)?(.+)\s*)?$'

  declare -i counter_criteria counter_commands
  
  while read -r  ; do

    line="${prevline:+$prevline }$REPLY"

    if [[ $line =~ \\$ ]]; then
      prevline=${line%\\}
      continue
    else
      unset prevline
    fi

    if [[ $line =~ ^[[:space:]]*$ ]]; then
      continue
    elif [[ $line =~ ^[[:space:]]*# ]]; then
      continue
    elif [[ $line =~ $re_set ]]; then
      vars["${BASH_REMATCH[1]}"]=${BASH_REMATCH[2]}
    elif [[ $line =~ ^[[:space:]]+(.+)[[:space:]]*$ ]]; then

      cmd=${BASH_REMATCH[1]}
      for k in "${!vars[@]}"; do
        cmd=${cmd//\$$k/${vars[$k]}}
      done

      # use command id instead of storing cmd string

      while ((counter_commands < counter_criteria)); do
        commands[counter_commands++]=$cmd
      done

    elif [[ $line =~ $re_rule ]]; then
      # re_rules=^(GLOBAL|DEFAULT)?((\s+)?(.+)\s*)?$
      is_global_rule=${BASH_REMATCH[1]}

      # group by comma
      mapfile -t ignore_combined <<< "${BASH_REMATCH[4]//,/$'\n'}"

      for crit in "${ignore_combined[@]}"; do

        # if we don't have  a criteria it is
        # a line with a single GLOBAL/NORMAL
        # we set the rule to nonsense (-)
        # to make sure it never matches
        [[ $crit ]] \
          && rule="class:.*:instance:.*:title:.*:window_type:.*:" \
          || rule=-

        while [[ $crit =~ $re_group ]]; do

          # re_group='(\s*([^=[:space:]]+)=([^=]+\S)\s*)$'

          crit=${crit:0:$((${#BASH_REMATCH[1]}*-1))}
          key=${BASH_REMATCH[2]} 
          val=${BASH_REMATCH[3]//\\s/[[:space:]]}
          val=${val// /[[:space:]]}

          # remove double quotes
          val=${val#\"} val=${val%\"}

          # ^ and $
          if [[ $val =~ ^\^(.+)\$$ ]]; then
            val="(${BASH_REMATCH[1]})"
          elif [[ $val =~ ^\^(.+) ]]; then
            val="(${BASH_REMATCH[1]})[^:]*"
          elif [[ $val =~ ^(.+)\$$ ]]; then
            val="[^:]*(${BASH_REMATCH[1]})"
          fi

          rule=${rule/$key:.\*:/$key:$val:}
        done

        [[ -a $_file_log ]] && echo "$rule" >> "$_file_log"

        if [[ $is_global_rule = DEFAULT ]]; then
          default_rules[counter_criteria++]=$rule
        elif [[ $is_global_rule = GLOBAL ]]; then
          global_rules[counter_criteria++]=$rule
        else
          rules[counter_criteria++]=$rule
        fi
      done
    fi

  done < "$1"
}

# SC2034 __o appears unused.
# shellcheck disable=2034
declare -A __o
options="$(
  getopt --name "[ERROR]:i3king" \
    --options "c:ahv" \
    --longoptions "config:,no-restart,apply,json:,verbose,dryrun,log:,help,version," \
    -- "$@" || exit 98
)"

eval set -- "$options"
unset options

while true; do
  case "$1" in
    --config     | -c ) __o[config]="${2:-}" ; shift ;;
    --no-restart ) __o[no-restart]=1 ;; 
    --apply      | -a ) __o[apply]=1 ;; 
    --json       ) __o[json]="${2:-}" ; shift ;;
    --verbose    ) __o[verbose]=1 ;; 
    --dryrun     ) __o[dryrun]=1 ;; 
    --log        ) __o[log]="${2:-}" ; shift ;;
    --help       | -h ) ___printhelp && exit ;;
    --version    | -v ) ___printversion && exit ;;
    -- ) shift ; break ;;
    *  ) break ;;
  esac
  shift
done

[[ ${__lastarg:="${!#:-}"} =~ ^--$|${0}$ ]] \
  && __lastarg="" 


main "${@:-}"


